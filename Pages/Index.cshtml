@page
@model IndexModel
@{
    ViewData["Title"] = "Demande d'aide financière de dernier recours";
    ViewData["masquerPremierEspaceurConteneurColonnes"] = true;
}

@section style{
    
    <style>
        .formulate-input-errors{
            margin: 0;
            padding: 0;
        }
    </style>
}
@section colonneGauche{
    <div id="form">
        @*<template>
                <formulate-form v-model="values"
                                :schema="schema"></formulate-form>
            </template>*@


        <template>
            @Html.Raw(Model.Formulaire)
        </template>
    </div>
}

@section colonneDroite{

}

@section scripts{
    <script src="https://unpkg.com/vue"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="form/formulate.min.js"></script>
    <script src="form/locales.min.js"></script>
    <script src="form/mtess-vueformulate.min.js"></script>

    <script>
        
    Vue.component('Label', MtessVueformulate.Label)
    Vue.component('ErrorList', MtessVueformulate.ErrorList)
    Vue.component('RepeatableRemove', MtessVueformulate.RepeatableRemove)

/*        classes: {
            outer: 'form-group',
                input: 'form-control',
                    inputHasErrors: 'is-invalid',
                        help: 'form-text text-muted',
                            errors: 'list-unstyled text-danger'
        },*/

    Vue.use(VueFormulate, {
        plugins: [this.VueFormulateI18n.fr],
        classes: {
            outer: (context, baseClasses) => {
                return obtenirClassesOuter(context, baseClasses)
            },
            error: 'text-danger field-validation-error',
            input: (context, baseClasses) => {
                return obtenirClassesInput(context, baseClasses)
            }
        },
        slotComponents: {
            label: 'Label',
            errorList: 'ErrorList',
            remove: 'RepeatableRemove'
        },
        locale: 'fr',
        validationNameStrategy: ['validationName', 'label', 'name', 'type']
    });

    const App = {
        el: '#form',
        methods: {
            failedValidation(data) {
                this.$el.setAttribute('data-submit', true)
                console.log('failedValidation')
                // console.log(data)
            },
            submitRawHandler(data) {
                // TODO ici trouver le moyen d'exécuter la méthode terminerTraitementEnCoursSoumissionForm lorsque notre code ECS qui disable le bouton est terminé... Sinon le bouton reste disabled.
                // Le setTimeout est utilisé afin de s'assurer que le traitement de soumission de formulaire qui ajoute spinner et disable et bien terminé.                 
                setTimeout(function () {
                    terminerTraitementEnCoursSoumissionForm() 
                },800)  
            },           
            submitHandler(data) {
                axios.post('/Privacy', data)
            },
            invalidMessage(fields) {
                console.log('invalidMessage')
                const listeErreurs = []
                const nomChamps = Object.keys(fields)

                nomChamps.forEach(nomChamp => {
                    const champ = fields[nomChamp]
                    if (champ.hasVisibleErrors) {
                        if (champ.context && champ.context.type !== 'group') {
                            this.ajouterErreursChamp(champ, listeErreurs)
                        } else {
                            this.ajouterErreursGroupe(champ, listeErreurs)
                        }
                    }
                })
                return JSON.stringify(listeErreurs)
            },
            ajouterErreursChamp(champ, listeErreurs) {
                champ.context.visibleValidationErrors.forEach(message => {
                    listeErreurs.push({ id: champ.context.id, message: message })
                })
            },
            ajouterErreursGroupe(groupe, listeErreurs) {
                if (groupe.allErrors.length > 1) {
                    // Erreurs haut niveau du groupe
                    const idGroupe = groupe._data.defaultId
                    groupe.$el.setAttribute('id', idGroupe)
                    for (var i = 1; i < groupe.allErrors.length; i++) {
                        listeErreurs.push({ id: idGroupe, message: groupe.allErrors[i] })
                    }
                }
                groupe.$children.forEach(enfant => {
                    this.ajouterErreursEnfant(enfant, listeErreurs)
                })
                // listeErreurs.push({ id: idGroupe, message: 'Le groupe "' + groupe.label + '" contient au moins une erreur."' })
            },
            ajouterErreursEnfant(enfant, listeErreurs) {
                if (enfant.isSubField && enfant.isSubField()) {
                    const idEnfant = enfant.context.attributes.id

                    enfant.visibleValidationErrors.forEach(message => {
                        listeErreurs.push({ id: idEnfant, message: message })
                    })
                } else {
                    enfant.$children.forEach(enfant => {
                        this.ajouterErreursEnfant(enfant, listeErreurs)
                    })
                }
            },
            ajouterErreursGroupe2(groupe, listeErreurs) {
                const conteneursChamps = groupe.$el.querySelectorAll('.formulate-input')
                console.log('A -> ' + conteneursChamps.length)
                conteneursChamps.forEach(conteneurChamp => {
//                    if (conteneurChamp.hasAttribute('data-has-errors')) {
                        console.log('B')
                        const label = conteneurChamp.querySelector('label')
                        const messages = conteneurChamp.querySelectorAll('.formulate-input-error')

                        if (label && messages.length > 0) {
                            console.log('C')
                            const id = label.getAttribute('for')

                            messages.forEach(message => {
                                console.log('D')
                                listeErreurs.push({ id: id, message: message.innerText })
                            })
                        }
                    //}
                })
                console.log("Erreurs -> " + listeErreurs)
            }
        },
        data: {
            contenuform: {},
            formErrors: [],
            inputErrors: {}
        },
       @*/* data: {
            values: {},
            schema: @Html.Raw(Model.Formulaire)
        },
        */*@
        mounted() {
            console.log('Application mounted.')
        }
    }

    window.addEventListener('load', () => {
        new Vue(App)
    })

        function obtenirClassesInput(context, baseClasses) {
            switch (context.classification) {
                case "text":
                case "textArea":
                case "select": 
                    baseClasses.push('form-control')
                    break
                case "button":
                    if (context.type === 'submit') {
                        baseClasses.push('btn btn-primaire')
                    }
                    break
            }

            return baseClasses
        }

        function obtenirClassesOuter(context, baseClasses) {
            switch (context.classification) {
                case "text":
                case "group":
                case "textArea":
                case "select":
                    baseClasses.push('form-group')
                    break
            }

            return baseClasses
        }

        function obtenirTexteEdite(id) {
            return '(Patch) Non défini.'
        }

    </script>
}