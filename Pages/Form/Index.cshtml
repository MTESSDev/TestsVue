@page "{id?}"
@model GenericModel
@{
    ViewData["H1NonRendu"] = true;
    ViewData["Title"] = "Formulaire";
}

@{
    // here we do the serialization of our dictionary into JSON using Newtonsoft.Json package
    // this object will be used in our Vue application

    // over the years of web development, I've found out that the following
    // serialization solves the problems I've encountered so far

    // in a real app this would be created as a helper method somewhere
    // if we want to exclude the c# code from our view
    var serializationSettings = new Newtonsoft.Json.JsonSerializerSettings()
    {
        ContractResolver = new Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver(),
        StringEscapeHandling = Newtonsoft.Json.StringEscapeHandling.EscapeHtml
    };

    var data =
        Html.Raw(
             System.Web.HttpUtility.JavaScriptStringEncode(
                  Newtonsoft.Json.JsonConvert.SerializeObject(
                    Model.VueData, Newtonsoft.Json.Formatting.None, serializationSettings
                ),
             false)
        );
}


@section style{

    <style>
        .formulate-input-errors {
            margin: 0;
            padding: 0;
        }
    </style>
}

@section colonneGauche{
    <nav>
        <nav class="navigation-form">
            <ul>
                <li v-for="page in pages" :key="page.no">
                    <a href="#" v-on:click.stop.prevent="effectuerNavigation(page.id)" v-bind:class="{active : page.id === form.idPageCourante}">{{ page.titre }}</a>
                </li>
            </ul>
        </nav>
    </nav>
}

@section colonneDroite{
    <h1>{{obtenirTitrePageCourante()}}</h1>
    <div id="form">
        <template>
            @Html.Raw(Model.FormRaw)
        </template>
    </div>
}


@section scripts{
    <script src="https://unpkg.com/vue/dist/vue.min.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="~/form/formulate.min.js"></script>
    <script src="~/form/locales.min.js"></script>
    <script src="~/form/mtess-vueformulate.min.js"></script>

    <script>

    Vue.component('Label', MtessVueformulate.Label)
    Vue.component('ErrorList', MtessVueformulate.ErrorList)
    Vue.component('RepeatableRemove', MtessVueformulate.RepeatableRemove)

    Vue.use(VueFormulate, {
        plugins: [this.VueFormulateI18n.fr],
        classes: {
            error: 'text-danger field-validation-error'
        },
        slotComponents: {
            label: 'Label',
            errorList: 'ErrorList',
            remove: 'RepeatableRemove'
        },
        locale: 'fr',
        validationNameStrategy: ['validationName', 'label', 'name', 'type']
    });

    const App = {
        el: '#main',
        methods: {
            failedValidation(data) {
                this.$el.setAttribute('data-submit', true)
                console.log('failedValidation')
                // console.log(data)
            },
            submitRawHandler(data) {
                // TODO ici trouver le moyen d'exécuter la méthode terminerTraitementEnCoursSoumissionForm lorsque notre code ECS qui disable le bouton est terminé... Sinon le bouton reste disabled.
                // Le setTimeout est utilisé afin de s'assurer que le traitement de soumission de formulaire qui ajoute spinner et disable et bien terminé.
                setTimeout(function () {
                    terminerTraitementEnCoursSoumissionForm()
                }, 800);
            },
            submitHandler(data) {
                axios.post('/Privacy', data)
            },
            invalidMessage(fields) {
                console.log('invalidMessage')
                const listeErreurs = []
                const nomChamps = Object.keys(fields)

                nomChamps.forEach(nomChamp => {
                    const champ = fields[nomChamp]
                    //if (champ.hasVisibleErrors) {
                    if (champ.hasErrors) {
                        if (champ.context && champ.context.type !== 'group') {
                            this.ajouterErreursChamp(champ, listeErreurs)
                        } else {
                            this.ajouterErreursGroupe(champ, listeErreurs, true)
                        }
                    }
                })
                return JSON.stringify(listeErreurs)
            },
            ajouterErreursChamp(champ, listeErreurs) {
                //champ.context.visibleValidationErrors.forEach(message => {
                champ.context.validationErrors.forEach(message => {
                    listeErreurs.push({ id: champ.context.id, message: message })
                })
            },
            ajouterErreursGroupe(groupe, listeErreurs, ajouterErreursEnfants) {
                let erreursGroupe = []
                let erreursGroupeEnfants = []

                // Erreurs dans les enfants du groupe
                groupe.$children.forEach(enfant => {
                    this.ajouterErreursEnfant(enfant, erreursGroupeEnfants)
                })

                // Obtenir l'id du premier contrôle en erreur dans le groupe. S'il n'y en a pas, on utilise l'id du groupe (div) on rend le div focusable
                let idPremierControleErreurGroupe = erreursGroupeEnfants.length ? erreursGroupeEnfants[0].id : null
                if (!idPremierControleErreurGroupe) {
                    idPremierControleErreurGroupe = groupe._data.defaultId
                    groupe.$el.setAttribute('id', idPremierControleErreurGroupe)
                    groupe.$el.setAttribute('tabindex', '-1')
                }

                if (groupe.allErrors.length) {
                    // Erreurs haut niveau du groupe
                    groupe.allErrors.forEach(message => {
                        if (message !== true) {
                            erreursGroupe.push({ id: idPremierControleErreurGroupe, message: message })
                        }
                    })
                }

                if (erreursGroupe.length <= 0) {
                    // Aucun message erreur de haut niveau sur le groupe, on indique qu'il y a au moins une erreur et on pointe sur première champ erreur du groupe
                    erreursGroupe.push({ id: idPremierControleErreurGroupe, message: groupe.label + ' contient au moins une erreur.' })
                }

                listeErreurs.push(...erreursGroupe)

                if (ajouterErreursEnfants) {
                    listeErreurs.push(...erreursGroupeEnfants)
                }
            },
            ajouterErreursEnfant(enfant, listeErreurs) {
                if (enfant.isSubField && enfant.isSubFLinkield()) {
                    const idEnfant = enfant.context.attributes.id

                    //enfant.visibleValidationErrors.forEach(message => {
                    enfant.validationErrors.forEach(message => {
                        listeErreurs.push({ id: idEnfant, message: message })
                    })
                } else {
                    enfant.$children.forEach(enfant => {
                        this.ajouterErreursEnfant(enfant, listeErreurs)
                    })
                }
            },
            effectuerNavigation(idPage) {
                this.form.validAll = false
                this.config.keepData = true
                this.form.idPageCourante = idPage

                this.$nextTick(function () {
                    this.config.keepData = false

                    if (this.form.idPageCourante === 'revision') {
                        this.form.validAll = true
                        this.$formulate.submit('form')
                    }
                })
            },
            obtenirTitrePageCourante() {
                const page = this.pages.find(page => page.id === this.form.idPageCourante)
                return page ? page.titre : 'Page non trouvée'
            },
            sauvegarde() {
                axios.post('@Url.PageLink("save", null, new { id = "3003CC" } )', this.form);

                alert("Sauvegardé!");
            }
        },
        data: function() {
            return JSON.parse('@data');
        },
        mounted() {
            console.log('Application mounted.')
        }
    }

    window.addEventListener('load', () => {
        new Vue(App)
    })

    function obtenirTexteEdite(id) {
        return '(Patch) Non défini.'
    }

    </script>
}