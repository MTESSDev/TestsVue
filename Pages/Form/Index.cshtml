@page "{id?}"
@model GenericModel

@{
    Layout = Model.Layout ?? "_NoLayout";
}

@{
    ViewData["H1NonRendu"] = true;
    ViewData["Title"] = "Formulaire";
}

@{
    // here we do the serialization of our dictionary into JSON using Newtonsoft.Json package
    // this object will be used in our Vue application

    // over the years of web development, I've found out that the following
    // serialization solves the problems I've encountered so far

    // in a real app this would be created as a helper method somewhere
    // if we want to exclude the c# code from our view
    var serializationSettings = new Newtonsoft.Json.JsonSerializerSettings()
    {
        ContractResolver = new Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver(),
        StringEscapeHandling = Newtonsoft.Json.StringEscapeHandling.EscapeHtml
    };

    var data =
        Html.Raw(
             System.Web.HttpUtility.JavaScriptStringEncode(
                  Newtonsoft.Json.JsonConvert.SerializeObject(
                    Model.VueData, Newtonsoft.Json.Formatting.None, serializationSettings
                ),
             false)
        );
}


@section style{

    <style>
        .formulate-input-errors {
            margin: 0;
            padding: 0;
        }

        [v-cloak] {
            display: none;
        }
    </style>
}

@section colonneGauche{
    <nav v-cloak class="navigation-form">
        <ul>
            <li v-for="page in pages" :key="page.no" v-if="page['v-if'] === '' || eval(page['v-if'])" v-bind:class="{active : page.no === noPageCourante, 'contient-erreur' : page.contientErreurs, 'sans-erreur' : page.sansErreur}">
                <span class="texte"><a href="#" v-on:click.stop.prevent="effectuerNavigation(page.no)">{{ page.titre }}</a></span>
                <span class="puce">
                    <span class="icone-svg sm" aria-hidden="true"></span>
                </span>
            </li>
        </ul>
    </nav>
}

@section colonneDroite{
    <div v-cloak>
        <h1>{{pageCourante.titre}}</h1>
        <div id="form">
            <template>
                @Html.Raw(Model.FormRaw)
            </template>

            <div class="zone-boutons">
                <button class="btn btn-secondaire btn-enregistrer mobile" v-on:click="enregistrer">Enregistrer</button>
                <button class="btn btn-secondaire" v-on:click="effectuerNavigation(noPagePrecedente)" :disabled="pageCourante.no === 0">Précédent</button>
                <button class="btn btn-secondaire btn-enregistrer" v-on:click="enregistrer">Enregistrer</button>
                <button class="btn btn-secondaire" v-on:click="effectuerNavigation(noPageSuivante)" :disabled="pageCourante.no === pages.length - 1">Suivant</button>
            </div>
            <div v-if="new URLSearchParams(window.location.search).get('debug')" class="infos-developpeurs">
                {{form}}
            </div>
        </div>
    </div>
}


@section scripts{
    <script src="https://unpkg.com/vue/dist/vue.min.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="~/form/formulate.min.js"></script>
    <script src="~/form/locales.min.js"></script>
    <script src="~/form/mtess-vueformulate.min.js"></script>

    <script>

    Vue.component('Label', MtessVueformulate.Label)
    Vue.component('ErrorList', MtessVueformulate.ErrorList)
    Vue.component('RepeatableRemove', MtessVueformulate.RepeatableRemove)
    Vue.component('Repeatable', MtessVueformulate.Repeatable)

    Vue.use(VueFormulate, {
        plugins: [this.VueFormulateI18n.fr],
        classes: {
            error: ['text-danger', 'field-validation-error'],
            help: ['precision']
        },
        slotComponents: {
            label: 'Label',
            errorList: 'ErrorList',
            remove: 'RepeatableRemove',
            repeatable: 'Repeatable'
        },
        slotProps: {
            label: ['tooltip'],
            repeatable: ['instanceLabel']
        },
        locale: '@Model.Language',
        validationNameStrategy: ['validationName', 'label', 'name', 'type']
    });

    const App = {
        el: '#main',
        methods: {
            created(data) {
                @Html.Raw(Model.Created)
            },
            failedValidation(data) {
                this.$el.setAttribute('data-submit', true)
                console.log('failedValidation')
                // console.log(data)
            },
            submitRawHandler(data) {
                // TODO ici trouver le moyen d'exécuter la méthode terminerTraitementEnCoursSoumissionForm lorsque notre code ECS qui disable le bouton est terminé... Sinon le bouton reste disabled.
                // Le setTimeout est utilisé afin de s'assurer que le traitement de soumission de formulaire qui ajoute spinner et disable et bien terminé.

                
                setTimeout(function () {
                    terminerTraitementEnCoursSoumissionForm()
                }, 800);
            },
            submitHandler(data) {
                axios.post('/Privacy', data)
            },
            testRepeatableAdded() {
//                console.log('repeatableAdded model')
                console.log('testRepeatableAdded')
            },
            testRepeatableRemoved() {
                console.log('testRepeatableRemoved')
            },

            invalidMessage(fields) {
                const listeErreurs = []
                const nomChamps = Object.keys(fields)

                nomChamps.forEach(nomChamp => {
                    const champ = fields[nomChamp]
                    //if (champ.hasVisibleErrors) {
                    if (champ.hasErrors) {
                        if (champ.context && champ.context.type !== 'group') {
                            this.ajouterErreursChamp(champ, listeErreurs)
                        } else {
                            this.ajouterErreursGroupe(champ, listeErreurs, true)
                        }                        
                    }
                })

                return listeErreurs.length > 0 ? JSON.stringify(listeErreurs) : false
            },
            initialiserToolTips() {

                const template = `<div class="tooltip" role="tooltip">                                    
                                    <div class="tooltip-header">
                                        <span class="text"></span>
                                        <a href="#" class="btn-fermer-tooltip" role="button"><span class="icone-svg" aria-hidden="true"></span></a>
                                    </div>
                                    <div class="arrow"></div>
                                    <div class="tooltip-inner">
                                    </div>
                                  </div>`

                $('[data-toggle="tooltip"]').each(function () {

                    const $iconeTooltip = $(this)
                    const $conteneur = $iconeTooltip.parent()

                    //Initialisation du tooltip
                    $iconeTooltip.tooltip({ trigger: 'click', placement: 'top', template: template, container: $conteneur })

                    //Ajout des événements permettant de fermer le tooltip
                    $iconeTooltip.on('shown.bs.tooltip', function () {
                        const $tooltip = $conteneur.find('.tooltip').attr('tabindex', '-1').focus()

                        //Fermer le tooltip sur click du bouton X (fermer)
                        $conteneur.find('.btn-fermer-tooltip').on('click', function (e) {
                            e.preventDefault()
                            $iconeTooltip.tooltip('hide')    
                        })

                        //Fermer le tooltip lorsque qu'il n'a plus le focus ou que le focus n'est plus à l'intérieur
                        $tooltip.on('focusout', function () {
                            if ($tooltip[0].matches(':not(:focus-within)')){
                                $iconeTooltip.tooltip('hide')
                            }
                        })
                    })
                })
            },
            ajouterErreursChamp(champ, listeErreurs) {
                champ.formShouldShowErrors = true
                champ.context.validationErrors.forEach(message => {
                    listeErreurs.push({ name: champ.context.name, message: message })
                })
            },
            ajouterErreursGroupe(groupe, listeErreurs, ajouterErreursEnfants) {
                let erreursGroupe = []
                let erreursGroupeEnfants = []
                groupe.formShouldShowErrors = true

                // Traiter les erreurs dans les enfants du groupe
                groupe.$children.forEach(enfant => {
                    this.ajouterErreursEnfant(enfant, erreursGroupeEnfants)
                })

                // Obtenir l'id du premier contrôle en erreur dans le groupe. S'il n'y en a pas, on utilise l'id du groupe (div) on rend le div focusable
                let nomPremierControleErreurGroupe = erreursGroupeEnfants.length ? erreursGroupeEnfants[0].name : null
                if (!nomPremierControleErreurGroupe) {
                    nomPremierControleErreurGroupe = groupe._data.defaultId
                    groupe.$el.setAttribute('name', nomPremierControleErreurGroupe)
                    groupe.$el.setAttribute('id', nomPremierControleErreurGroupe)
                    groupe.$el.setAttribute('tabindex', '-1')
                }

                if (groupe.allErrors.length) {
                    // Erreurs haut niveau du groupe
                    groupe.allErrors.forEach(message => {
                        if (message !== true) {
                            erreursGroupe.push({ name: nomPremierControleErreurGroupe, message: message })
                        }
                    })
                }

                if (erreursGroupeEnfants.length > 0 && erreursGroupe.length == 0) {
                    // Aucun message erreur de haut niveau sur le groupe, on indique qu'il y a au moins une erreur et on pointe sur première champ erreur du groupe
                    erreursGroupe.push({ name: nomPremierControleErreurGroupe, message: groupe.label + ' contient au moins une erreur.' })
                }

                listeErreurs.push(...erreursGroupe)

                if (ajouterErreursEnfants) {
                    listeErreurs.push(...erreursGroupeEnfants)
                }
            },
            ajouterErreursEnfant(enfant, listeErreurs) {
                //if (enfant.isSubField && enfant.isSubFLinkield()) {

                enfant.formShouldShowErrors = true

                if (enfant.isSubField) {
                    const nameEnfant = enfant.context.attributes.name

                    enfant.validationErrors.forEach(message => {
                        listeErreurs.push({ name: nameEnfant, message: message })
                    })
                } else {
                    enfant.$children.forEach(enfant => {
                        this.ajouterErreursEnfant(enfant, listeErreurs)
                    })
                }
            },
            obtenirIdPageControle(controle) {
                return controle.parents('.section:first').attr('data-id-page')
            },
            effectuerNavigation(noPage, nomControleFocus, pasFocus) {
                this.form.validAll = false
                this.config.keepData = true

                //Obtenir la page courante et mettre à jour son indicateur d'erreurs (sauf page révision)
                if (this.pageCourante.id !== 'revision') {
                    const form = this.$formulate.registry.get("form")

                    this.pages[this.pageCourante.no].dirty = form.formContext.hasValue

                    //La 2ème portion de validation sert à pallier un bug avec les groupes (prop hasErrors = true, suite à navigation à partir page révision, même si aucune erreur pour vrai)
                    this.pages[this.pageCourante.no].contientErreurs = form.hasErrors && (form.invalidErrors.length === 0 || form.invalidErrors[0] !== false)
                    this.pages[this.pageCourante.no].sansErreur = !this.pages[this.pageCourante.no].contientErreurs
                }

                this.noPageCourante = noPage

                this.$nextTick(function () {
                    this.config.keepData = false
                    if (this.pageCourante.id === 'revision') {
                        this.form.validAll = true
                        this.$formulate.submit('form')
                    }

                    this.initialiserToolTips()

                    if (nomControleFocus) {
                        const controles = document.getElementsByName(nomControleFocus)
                        if (controles.length) {
                            if (!pasFocus) {
                                controles[0].focus()
                            }
                            this.repositionnerEcranLabelQuestion(controles[0].id)
                        } else {
                            /* Ici on traite essentiellement les erreurs de haut niveau sur les groupes (ex. un groupe obligatoire sans occurence)
                               setTimeout nécessaire afin que le rendering des erreurs soit fait. */
                            setTimeout(function (formulate) {
                                var controlesErreur = $("[data-has-errors]").find("input,textarea")
                                if (controlesErreur.length) {
                                    controlesErreur[0].focus()
                                    formulate.repositionnerEcranLabelQuestion(controlesErreur[0].id)
                                }
                            },0 ,this)                           
                        }
                    }
                })
            },
            obtenirNoProchainePageVisible() {

            },
            effectuerNavigationParId(idPage, nomControleFocus) {
                const page = this.obtenirPage(idPage)
                this.effectuerNavigation(page.no, nomControleFocus)
            },
            repositionnerEcranLabelQuestion(idControle) {
                //Le split permet d'aller chercher le label de la question associée à un bouton radio ou un checkbox. Pour les autres types de contrôles c'est le label du contrôle lui même (n'aura pas de _)
                var label = idControle.split('_');
                $("label[for^='" + label[0] + "']")[0].scrollIntoView();
            },
            obtenirPage(idPage) {
                return this.pages.find(page => page.id === idPage)
            },
            enregistrer() {
                axios.post('@Url.PageLink("save", null, new { id = "3003CC" } )', this.form);
                alert("Sauvegardé!");
            }
        },
        computed: {
            pageCourante() {
                return this.pages.find(page => page.no === this.noPageCourante)
            },
            noPageSuivante() {
                for (var i = this.noPageCourante + 1; i < this.pages.length; i++) {
                    if (this.pages[i]['v-if']) {
                        if (eval(this.pages[i]['v-if'].replace('form', 'this.form'))) {
                            return i;
                        }
                    } else {
                        return i;
                    }
                }
                return this.pages.length - 1;
            },
            noPagePrecedente() {
                for (var i = this.noPageCourante - 1; i > 0; i--) {
                    if (this.pages[i]['v-if']) {
                        if (eval(this.pages[i]['v-if'].replace('form', 'this.form'))) {
                            return i;
                        }
                    } else {
                        return i;
                    }
                }
                return 0;
            }

        },
        data: function() {
            return JSON.parse('@data');
        },
        mounted() {
            console.log('Application mounted.');
            this.initialiserToolTips()
        }
    }

    window.addEventListener('load', () => {
        new Vue(App)
    })

    function fermerTooltip() {
        alert('banane')
    }

    function obtenirTexteEdite(id) {
        return '(Patch) Non défini.'
    }
    </script>
}