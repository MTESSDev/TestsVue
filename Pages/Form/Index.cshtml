@page "{id?}"
@model GenericModel

@{
    Layout = Model.Layout ?? "_NoLayout";
}

@{
    ViewData["H1NonRendu"] = true;
    ViewData["Title"] = "Formulaire";
}

@{
    // here we do the serialization of our dictionary into JSON using Newtonsoft.Json package
    // this object will be used in our Vue application

    // over the years of web development, I've found out that the following
    // serialization solves the problems I've encountered so far

    // in a real app this would be created as a helper method somewhere
    // if we want to exclude the c# code from our view
    var serializationSettings = new Newtonsoft.Json.JsonSerializerSettings()
    {
        ContractResolver = new Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver(),
        StringEscapeHandling = Newtonsoft.Json.StringEscapeHandling.EscapeHtml
    };

    var data =
        Html.Raw(
             System.Web.HttpUtility.JavaScriptStringEncode(
                  Newtonsoft.Json.JsonConvert.SerializeObject(
                    Model.VueData, Newtonsoft.Json.Formatting.None, serializationSettings
                ),
             false)
        );
}


@section style{

    <style>
        .formulate-input-errors {
            margin: 0;
            padding: 0;
        }

        [v-cloak] {
            display: none;
        }
    </style>
}

@section colonneGauche{
    <nav v-cloak class="etapes-form navbar navbar-expand-lg">
        <a role="button" class="navbar-toggler collapsed" data-toggle="collapse"  aria-controls="navbarSupportedContent" aria-expanded="false"  href="#navbarSupportedContent" >
            <span class="libelle">
                Étapes du formulaire
            </span>
            <span aria-hidden="true" class="icone-svg md"></span>
        </a>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="niv1" >
                <li v-for="groupe in pagesGroup" :key="groupe.no" v-if="groupe['v-if'] === '' || eval(groupe['v-if'])" :class="{ 'sans-regroupement': !groupe.titre }" >
                    <span class="groupe" :class="groupe.classes" v-if="groupe.titre">{{ groupe.titre }}</span>
                    <ul class="niv2">

                        <li v-for="page in groupe.pages" :key="page.no" v-if="page['v-if'] === '' || eval(page['v-if'])" :class="[{active : page.no === noPageCourante, 'contient-erreur' : page.contientErreurs, 'sans-erreur' : page.sansErreur}, page.classes ? page.classes : '' ]">
                            <span class="texte"><a href="#" v-on:click.stop.prevent="effectuerNavigation(page.no)">{{ page.titre }}</a></span>
                            <span class="puce">
                                <span class="icone-svg sm" aria-hidden="true"></span>
                            </span>
                        </li>
                    </ul>
                </li>
            </ul>
        </div>
    </nav>
}

@section colonneDroite{
    <div v-cloak>
        <h1 tabindex="-1">{{pageCourante.titre}}</h1>
        <div id="form">
            <div class="d-none">{{estConsidereConjoint}}</div>
            <div class="texte-explicatif-champs-obligatoires d-flex justify-content-end" aria-hidden="true">
                <span class="icone-champ-requis" aria-hidden="true">&nbsp;*</span>
                <span>indique une réponse obligatoire.</span>
            </div>
            <template>
                @Html.Raw(Model.FormRaw)
            </template>

            <div class="zone-boutons bas-page">
                <button class="btn btn-secondaire" v-on:click="effectuerNavigation(noPagePrecedente)" :disabled="noPagePrecedente == null">Précédent</button>
                <button class="btn btn-secondaire btn-enregistrer" v-on:click="enregistrer">Enregistrer</button>
                <button class="btn btn-secondaire" v-on:click="effectuerNavigation(noPageSuivante)" :disabled="noPageSuivante == null">Suivant</button>
            </div>

            <div id="tooltipModal" class="modal aide-contextuelle" tabindex="-1" role="dialog" aria-labelledby="modal-title" style="display: block;" aria-modal="true">
                <div class="modal-header container" id="modal-header">
                    <h1 id="modal-title"><span class="sr-only">Aide à propos de</span><span id="dialog-title">{{tooltipTitle}}</span></h1>
                    <button type="button" class="close" data-dismiss="modal">
                        <span class="icone-svg x-fermer-bleu" aria-hidden="true"></span>
                    </button>
                </div>
                <div class="modal-content container">
                    <div class="modal-body">
                        <div id="dialog-description" class="dialog-content">
                            {{tooltipText}}
                        </div>
                    </div>
                </div>
            </div>

            <div v-if="new URLSearchParams(window.location.search).get('debug')" class="infos-developpeurs">
                {{form}}
            </div>
        </div>
    </div>
}


@section scripts{

    <script>

    Vue.component('Label', MtessVueformulate.Label)
    Vue.component('ErrorList', MtessVueformulate.ErrorList)
    Vue.component('RepeatableRemove', MtessVueformulate.RepeatableRemove)
    Vue.component('Repeatable', MtessVueformulate.Repeatable)

    Vue.use(VueFormulate, {
        plugins: [this.VueFormulateI18n.fr],
        classes: {
            error: ['text-danger', 'field-validation-error'],
            help: ['precision']
        },
        slotComponents: {
            label: 'Label',
            errorList: 'ErrorList',
            remove: 'RepeatableRemove',
            repeatable: 'Repeatable'
        },
        slotProps: {
            label: ['tooltipTitle', 'tooltipText'],
            repeatable: ['instanceLabel']
        },
        locale: '@Model.Language',
        validationNameStrategy: ['validationName', 'label', 'name', 'type'],
        rules: {
            nas: ({ value }, validerValeur) => {
                if (value) {
                    if (validerValeur) {
                        return estNAS(value)
                    } else {
                        const match = value.match(/\d{9}/gm)
                         return match && match.length > 0
                    }                    
                }
                return true
            }
        },
        locales: {
            fr: {
                nas({ name }) {
                    return `${name} n'a pas un format valide.`
                }
            }
        }
    });

    const App = {
        el: '#main',
        methods: {
            created(data) {
                @Html.Raw(Model.Created)
            },
            failedValidation(data) {
                this.$el.setAttribute('data-submit', true)
                console.log('failedValidation')
                // console.log(data)
            },
            submitRawHandler(data) {
                // TODO ici trouver le moyen d'exécuter la méthode terminerTraitementEnCoursSoumissionForm lorsque notre code ECS qui disable le bouton est terminé... Sinon le bouton reste disabled.
                // Le setTimeout est utilisé afin de s'assurer que le traitement de soumission de formulaire qui ajoute spinner et disable et bien terminé.
                axios.post('/Privacy/3003cc', this.form)
                    .then(response => {
                        console.log(response)
                    })
                    .catch(error => {
                        console.log(error.response.data);
                    });

                setTimeout(function () {
                    terminerTraitementEnCoursSoumissionForm()
                }, 800);
            },
            submitHandler(data) {
                axios.post('/Privacy', data)
            },
            repeatableAdded(model) {
                if (document.activeElement) {
                    const $conteneurGroupe = $(document.activeElement).parents('[data-type=group]:first')

                    if ($conteneurGroupe.length) {
                        const $tirroirs = $conteneurGroupe.find('.collapse')

                        if ($tirroirs.length) {
                            $tirroirs.collapse('hide')
                        }

                        this.$nextTick(function () {
                            const $contenuTirroirAjoute = $conteneurGroupe.find('.collapse:last')
                            if ($contenuTirroirAjoute.length) {
                                this.donnerFocusPremierElementFocusable($contenuTirroirAjoute[0])

                                //setTimeout requis pour FFox... Comme si animation tirroir bloquait le scrollIntoView. On scroll à l'avant dernier tirroir (ou au 1er si un seul)
                                setTimeout(function () {
                                    const $entetesTirroirs = $conteneurGroupe.find('[data-toggle=collapse]')
                                    if ($entetesTirroirs.length) {
                                        const i = $entetesTirroirs.length > 1 ? $entetesTirroirs.length - 2 : 0
                                        $entetesTirroirs[i].scrollIntoView()
                                    }
                                })
                            }
                        })
                    }
                }
            },
            repeatableRemoved(model) {
                if (document.activeElement) {
                    const $conteneurGroupe = $(document.activeElement).parents('[data-type=group]:first')

                    this.$nextTick(function () {

                        //On scroll à l'avant dernier tirroir (ou au 1er si un seul)
                        const $entetesTirroirs = $conteneurGroupe.find('[data-toggle=collapse]')
                        if ($entetesTirroirs.length) {
                            const i = $entetesTirroirs.length > 1 ? $entetesTirroirs.length - 2 : 0
                            $entetesTirroirs[i].scrollIntoView()
                        }
                    })
                }
            },
            //TODO éventuellement bonifier afin de supporter les valeurs dans des groupes répétables.
            val(idChamp) {
                const champs = idChamp.split('.')
                let objetAValider = this.form

                for (champ of champs) {

                    //TODO à modifier éventuellement pour groupes répétables
                    objetAValider = Array.isArray(objetAValider) ? objetAValider[0] : objetAValider

                    if (!objetAValider[`${champ}`] && objetAValider[`${champ}`] !== false ) {
                        return ''
                    }
                    objetAValider = objetAValider[`${champ}`]
                }              

                return objetAValider || ''
            },
            valGroupe(nomGroupe, idChamp, indexe) {
                indexe = indexe || 0
                const groupe = this.form[`${nomGroupe}`]

                if (groupe) {
                    if (idChamp) {
                        const instance = groupe[indexe]

                        if (instance) {
                            const valeurChamp = instance[`${idChamp}[${indexe}]`]

                            if (valeurChamp || valeurChamp === false) {
                                //On retourne la valeur du champ à l'instance spécifiée ou 0 par défaut
                                return valeurChamp
                            }
                        }
                    } else {
                        //On retourne le groupe (array)
                        return groupe
                    }
                }
                
                return ''
            },

            //TODO évaluer possibilité d'en faire une fonction commune
            donnerFocusPremierElementFocusable(conteneur) {
                var elementsFocusables = obtenirElementsFocusables(conteneur);
                if (elementsFocusables.length > 0) {
                    elementsFocusables[0].focus();
                    return true
                }
                return false
            },
            invalidMessage(fields) {
                const listeErreurs = []
                const nomChamps = Object.keys(fields)

                nomChamps.forEach(nomChamp => {
                    const champ = fields[nomChamp]
                    //if (champ.hasVisibleErrors) {
                    if (champ.hasErrors) {
                        if (champ.context && champ.context.type !== 'group') {
                            this.ajouterErreursChamp(champ, listeErreurs)
                        } else {
                            this.ajouterErreursGroupe(champ, listeErreurs, true)
                        }
                    }
                })

                return listeErreurs.length > 0 ? JSON.stringify(listeErreurs) : false
            },
/*            initialiserToolTips() {

                const template = `<div class="tooltip" role="tooltip">
                                    <div class="tooltip-header">
                                        <span class="text"></span>
                                        <a href="#" class="btn-fermer-tooltip" role="button">
                                            <span class="icone-svg" aria-hidden="true"></span>
                                        </a>
                                    </div>
                                    <div class="arrow"></div>
                                    <div class="tooltip-inner"></div>
                                  </div>`

                $('[data-toggle="tooltip"]').each(function () {

                    const $iconeTooltip = $(this)
                    const $conteneur = $iconeTooltip.parent()

                    //Initialisation du tooltip
                    $iconeTooltip.tooltip({ trigger: 'click', placement: 'top', template: template, container: $conteneur})

                    //Ajout des événements permettant de fermer le tooltip
                    $iconeTooltip.on('shown.bs.tooltip', function () {
                        const $tooltip = $conteneur.find('.tooltip').attr('tabindex', '-1').focus()

                        //Fermer le tooltip sur click du bouton X (fermer)
                        $conteneur.find('.btn-fermer-tooltip').on('click', function (e) {
                            e.preventDefault()
                            $iconeTooltip.tooltip('hide')
                        })

                        //Fermer le tooltip lorsque qu'il n'a plus le focus ou que le focus n'est plus à l'intérieur
                        $tooltip.on('focusout', function () {
                            if ($tooltip[0].matches(':not(:focus-within)')){
                                $iconeTooltip.tooltip('hide')
                            }
                        })
                    })
                })
            },*/
            ajouterErreursChamp(champ, listeErreurs) {
                champ.formShouldShowErrors = true
                champ.context.validationErrors.forEach(message => {
                    listeErreurs.push({ name: champ.context.name, message: message })
                })
            },
            ajouterErreursGroupe(groupe, listeErreurs, ajouterErreursEnfants) {
                let erreursGroupe = []
                let erreursGroupeEnfants = []
                groupe.formShouldShowErrors = true

                // Traiter les erreurs dans les enfants du groupe
                groupe.$children.forEach(enfant => {
                    this.ajouterErreursEnfant(enfant, erreursGroupeEnfants)
                })

                // Obtenir l'id du premier contrôle en erreur dans le groupe. S'il n'y en a pas, on utilise l'id du groupe (div) on rend le div focusable
                let nomPremierControleErreurGroupe = erreursGroupeEnfants.length ? erreursGroupeEnfants[0].name : null
                if (!nomPremierControleErreurGroupe) {
                    nomPremierControleErreurGroupe = groupe._data.defaultId
                    groupe.$el.setAttribute('name', nomPremierControleErreurGroupe)
                    groupe.$el.setAttribute('id', nomPremierControleErreurGroupe)
                    groupe.$el.setAttribute('tabindex', '-1')
                }

                if (groupe.allErrors.length) {
                    // Erreurs haut niveau du groupe
                    groupe.allErrors.forEach(message => {
                        if (message !== true) {
                            erreursGroupe.push({ name: nomPremierControleErreurGroupe, message: message })
                        }
                    })
                }

                if (erreursGroupeEnfants.length > 0 && erreursGroupe.length == 0) {
                    // Aucun message erreur de haut niveau sur le groupe, on indique qu'il y a au moins une erreur et on pointe sur première champ erreur du groupe
                    erreursGroupe.push({ name: nomPremierControleErreurGroupe, message: groupe.label + ' contient au moins une erreur.' })
                }

                listeErreurs.push(...erreursGroupe)

                if (ajouterErreursEnfants) {
                    listeErreurs.push(...erreursGroupeEnfants)
                }
            },
            ajouterErreursEnfant(enfant, listeErreurs) {
                //if (enfant.isSubField && enfant.isSubFLinkield()) {

                enfant.formShouldShowErrors = true

                if (enfant.isSubField) {
                    const nameEnfant = enfant.context.attributes.name

                    enfant.validationErrors.forEach(message => {
                        listeErreurs.push({ name: nameEnfant, message: message })
                    })
                } else {
                    enfant.$children.forEach(enfant => {
                        this.ajouterErreursEnfant(enfant, listeErreurs)
                    })
                }
            },
            obtenirIdPageControle(controle) {
                return controle.parents('.section:first').attr('data-id-page')
            },
            showTooltip(title, text) {
                this.tooltipTitle = title || ''
                this.tooltipText = text || ''
                $('#tooltipModal').modal()
            },
            initialiserTooltips() {
                //Fermer le tooltip(modal) lorsque qu'il n'a plus le focus ou que le focus n'est plus à l'intérieur
                const $tooltipModal = $("#tooltipModal")
                $tooltipModal.on('focusout', function () {
                    if ($tooltipModal[0].matches(':not(:focus-within)')) {
                        $tooltipModal.modal('hide')
                    }
                }); //TODO ici trouver pourquoi la modale ne se ferme pas quand on clic en dehors (devrait être le comportement par défaut.)
                //Conserver le focus dans la modale de tooltip sur TAB, SHIFT-TAB
                conserverFocusElement($tooltipModal.get(0))
            },
            effectuerNavigation(noPage, nomControleFocus, pasFocus) {
                this.form.validAll = false
                this.config.keepData = true

                //Obtenir la page courante et mettre à jour son indicateur d'erreurs (sauf page révision)
                if (this.pageCourante.id !== 'revision') {
                    const form = this.$formulate.registry.get("form")

                    this.pageCourante.dirty = form.formContext.hasValue

                    //La 2ème portion de validation sert à pallier un bug avec les groupes (prop hasErrors = true, suite à navigation à partir page révision, même si aucune erreur pour vrai)
                    this.pageCourante.contientErreurs = form.hasErrors && (form.invalidErrors.length === 0 || form.invalidErrors[0] !== false)
                    this.pageCourante.sansErreur = !this.pageCourante.contientErreurs
                }

                this.noPageCourante = noPage

                this.$nextTick(function () {
                    this.config.keepData = false
                    if (this.pageCourante.id === 'revision') {
                        this.form.validAll = true
                        this.$formulate.submit('form')
                    }

                    if (nomControleFocus) {
                        const controles = document.getElementsByName(nomControleFocus)
                        if (controles.length) {
                            if (!pasFocus) {
                                controles[0].focus()
                            }
                            this.repositionnerEcranLabelQuestion(controles[0].id)
                        } else {
                            /* Ici on traite essentiellement les erreurs de haut niveau sur les groupes (ex. un groupe obligatoire sans occurence)
                               setTimeout nécessaire afin que le rendering des erreurs soit fait. */
                            setTimeout(function (formulate) {
                                var controlesErreur = $("[data-has-errors]").find("input,textarea")
                                if (controlesErreur.length) {
                                    controlesErreur[0].focus()
                                    formulate.repositionnerEcranLabelQuestion(controlesErreur[0].id)
                                }
                            }, 0, this)
                        }
                    } else {
                        //On traite une navigation sans contrôle spécifié à qui donner le focus (ex. page suivante/précédente ou clic sur une page dans menu gauche). On donne focus au H1.
                        const h1 = document.getElementsByTagName('h1')[0]
                        h1.focus()
                        h1.scrollIntoView() /* Sous IOS le focus ne semble pas provoquer un scroll à tout coup... on le force */
                    }
                })
            },
            effectuerNavigationParId(idPage, nomControleFocus) {
                const page = this.obtenirPageParId(idPage)
                this.effectuerNavigation(page.no, nomControleFocus)
            },
            repositionnerEcranLabelQuestion(idControle) {
                //Le split permet d'aller chercher le label de la question associée à un bouton radio ou un checkbox. Pour les autres types de contrôles c'est le label du contrôle lui même (n'aura pas de _)
                var label = idControle.split('_');
                $("label[for^='" + label[0] + "']")[0].scrollIntoView();
            },
            obtenirPageParId(idPage) {
                for (const groupe of this.pagesGroup) {
                    const page = groupe.pages.find(page => page.id === idPage)
                    if (page) {
                        return page
                    }
                }
            },
            obtenirPageParNo(noPage) {
                for (const groupe of this.pagesGroup) {
                    const page = groupe.pages.find(page => page.no === noPage)
                    if (page) {
                        return { groupe: groupe, page: page }
                    }
                }
            },
            estPageAffichee(groupeEtPage) {

                const groupe = groupeEtPage.groupe
                const page = groupeEtPage.page
                const form = this.form
                const val = this.val
                if (groupe['v-if']) {
                    if (eval(groupe['v-if'])) {
                        if (page['v-if']) {
                            if (eval(page['v-if'])) {
                                return true
                            }
                        } else {
                            return true
                        }
                    }
                } else {
                    if (page['v-if']) {
                        if (eval(page['v-if'])) {
                            return true
                        }
                    } else {
                        return true;
                    }
                }
                return false
            },
            enregistrer() {
                axios.post('@Url.PageLink("save", null, new { id = "3003CC" } )', this.form);
                alert("Sauvegardé!");
            }
        },
        computed: {
            pageCourante() {
                return this.obtenirPageParNo(this.noPageCourante).page
            },
            noPageSuivante() {
                let noPageSuivante = this.noPageCourante + 1
                let groupeEtPage = this.obtenirPageParNo(noPageSuivante)

                while (groupeEtPage) {                    

                    if (this.estPageAffichee(groupeEtPage)) {
                        return groupeEtPage.page.no
                    }

                    noPageSuivante += 1
                    groupeEtPage = this.obtenirPageParNo(noPageSuivante)
                }

                return null
            },
            noPagePrecedente() {
                let noPagePrecedente = this.noPageCourante - 1
                let groupeEtPage = this.obtenirPageParNo(noPagePrecedente)

                while (groupeEtPage) {

                    if (this.estPageAffichee(groupeEtPage)) {
                        return groupeEtPage.page.no
                    }

                    noPagePrecedente -= 1
                    groupeEtPage = this.obtenirPageParNo(noPagePrecedente)
                }

                return null
            },
            estConsidereConjoint() {
                this.form.Conjoint = (this.val('PrecisionsAdulte2.MarieUniCivilementAdulte') === 'true' || this.val('PrecisionsAdulte2.AutreParentEnfant') === 'true' || this.val('PrecisionsAdulte2.VieMaritaleUnAn') === 'true' || this.val('PrecisionsAdulte2.ViePasseeMaritaleUnAn') === 'true').toString()
                return this.form.Conjoint
            },
        },
        data: function () {
            let donnees = JSON.parse('@data')
            donnees['tooltipTitle'] = ''
            donnees['tooltipText'] = ''
            return donnees;
        },
        mounted() {
            console.log('Application mounted.');
            this.initialiserTooltips()
        }
    }

    window.addEventListener('load', () => {
        new Vue(App)
    })

    function obtenirTexteEdite(id) {
        return '(Patch) Non défini.'
        }

    function estNAS(n) { if (typeof n == 'number' && n >= 0 && n < 1000000000 && n % 1 == 0) n = ('0'.repeat(8) + String(n)).slice(-9); if (!/^[0-9]{3}[ -]?[0-9]{3}[ -]?[0-9]{3}$/.test(n = String(n))) return false; n = n.replace(/[^0-9]/g, ''); return [].map.call(n, function (v, k) { var m = (k % 2) + 1, v = parseInt(v) * m; if (v > 10) return 1 + (v % 10); return v; }).reduce(function (a, b) { return a + b; }, 0) % 10 == 0; }

    </script>
}